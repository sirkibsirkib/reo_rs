// Generated by Reo 1.0

#[allow(unused_imports)]
use maplit::{hashmap, hashset};

pub use reo_rs::*;
use reo_rs::building::{*, NameDef::*};
use reo_rs::Instruction::*;
use reo_rs::Term::*;

#[no_mangle]
pub extern fn reors_generated_proto_create() -> CProtoHandle {
    reo_rs::to_c_proto(proto_protocol1_build_rust::<isize,isize,isize>())
}

pub fn proto_protocol1_build_rust<T0, T1, T2>(
) -> ProtoHandle
where
    T0: 'static + Send + Sync + Sized,
    T1: 'static + Send + Sync + Sized,
    T2: 'static + Send + Sync + Sized,
{
    let name_defs = hashmap!{
        "a" => Port { is_putter:  true, type_info: TypeInfo::of::<T0>() },
        "b" => Port { is_putter: false, type_info: TypeInfo::of::<T1>() },
        "m1" => Mem(TypeInfo::of::<T1>()),
    };
    let rules = vec![
        RuleDef {
            state_guard: StatePredicate {
                ready_ports: hashset! {"b", },
                full_mem: hashset! {"m1", },
                empty_mem: hashset! {},
            },
            ins: vec![
            ],
            output: hashmap!{
                "m1" => (false, hashset!{"b", }),
            }
        },
        RuleDef {
            state_guard: StatePredicate {
                ready_ports: hashset! {"a", "m1", },
                full_mem: hashset! {"m1", },
                empty_mem: hashset! {},
            },
            ins: vec![
                MemSwap("m1", "m1_Next"),
                Check(False),
            ],
            output: hashmap!{
                "a" => (false, hashset!{"m1_NEXT", }),
                "m1" => ( true, hashset!{}),
            }
        },
    ];
    let mem_init = MemInitial::default();
    ProtoDef {
        name_defs,
        rules
    }.build(mem_init).expect("Oh no! Reo failed to build!")
}

